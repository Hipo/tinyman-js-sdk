"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("algosdk"),e=require("base64-js");function s(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var a=s(t);const n={testnet:62368684,mainnet:552635992};const o="- would result negative",r="logic eval error:",i="exceeds schema integer count",u=/transaction \w+:/;class c extends Error{constructor(t,e,...s){super(...s);const a=this.extractMessageFromAlgoSDKError(t);this.data=t,this.type=this.getErrorType(a),this.setMessage(this.getErrorMessage(a,this.type,e))}setMessage(t){this.message=t}getErrorType(t){let e="Unknown";return t.includes(o)?e="SlippageTolerance":t.includes(i)?e="ExceedingExcessAmountCount":t.includes(r)?e="LogicError":t.match(u)&&(e="TransactionError"),e}getErrorMessage(t,e,s){let a;switch(e){case"SlippageTolerance":a="The process failed due to too much slippage in the price. Please adjust the slippage tolerance and try again.";break;case"ExceedingExcessAmountCount":a="The process failed due to the number of excess amounts accumulated for your account in the Tinyman app.";break;case"LogicError":a=t.split(r)[1];break;case"TransactionError":a=t.split(u)[1];break;case"Unknown":t&&(a=t)}return a||(a=s||"We encountered an unexpected error, try again later."),a.trim()}extractMessageFromAlgoSDKError(t){let e="";return t?.response?.body?.message?e=t.response.body.message:t?.response?.text?e=t.response.text:"string"==typeof t?.message&&(e=this.isMessageObjectString(t?.message)?JSON.parse(t.message||"{message: ''}").message:t.message),"string"!=typeof e&&(e=String(e)),e}isMessageObjectString(t){return"string"==typeof t&&t.includes("{message:")}}function d(t=[]){const e={};for(const s of t){const{key:t}=s;let a;if(1==s.value.type)a=s.value.bytes;else{if(2!=s.value.type)throw new Error(`Unexpected state type: ${s.value.type}`);a=s.value.uint}e[t]=a}return e}function l(t){let e=t.reduce(((t,e)=>t+e.length),0),s=new Uint8Array(e),a=0;for(let e of t)s.set(e,a),a+=e.length;return s}const A=100000n,I=100000n,g=100000n,m=25000n+25000n,p=25000n+3500n;async function T(t,e){var s;for(await(s=1e3,new Promise((t=>{setTimeout((()=>{t(null)}),s)})));;){let s=null;try{s=await t.pendingTransactionInformation(e).do()}catch(t){}if(s){if(s["confirmed-round"])return s;if(s["pool-error"])throw new Error(`Transaction Rejected: ${s["pool-error"]}`)}}}function E(t,e,s){if(e>1||e<0)throw new Error(`Invalid slippage value. Must be between 0 and 1, got ${e}`);let a;try{const n="negative"===t?1-e:1+e;a=BigInt(Math.floor(Number(s)*n))}catch(t){throw new Error(t.message)}return a}function D(t,e){const s=Number(t);return f({decimalPlaces:s},Math.pow(10,-s)*Number(e))}function f({decimalPlaces:t=0},e){return Number(Math.round(Number(e+`e+${t}`))+`e-${t}`)}async function x(t,e){try{let s=[];for(let a of e){const{txId:e}=await t.sendRawTransaction(a).do(),n=(await T(t,e))["confirmed-round"];s.push({confirmedRound:n,txnID:e})}return s}catch(t){throw new c(t,"We encountered an error while processing this transaction. Try again later.")}}function N(t){return t.reduce(((t,e)=>t+e.txn.fee),0)}function S(t){return(e=t[0].txn.group)?Buffer.from(e).toString("base64"):"";var e}function y(t){return(new TextEncoder).encode(t)}var _={type:"logicsig",logic:{bytecode:"BCAIAQCBgICAgICAgPABgICAgICAgIDwAQMEBQYlJA1EMQkyAxJEMRUyAxJEMSAyAxJEMgQiDUQzAQAxABJEMwEQIQcSRDMBGIGCgICAgICAgPABEkQzARkiEjMBGyEEEhA3ARoAgAlib290c3RyYXASEEAAXDMBGSMSRDMBG4ECEjcBGgCABHN3YXASEEACOzMBGyISRDcBGgCABG1pbnQSQAE7NwEaAIAEYnVybhJAAZg3ARoAgAZyZWRlZW0SQAJbNwEaAIAEZmVlcxJAAnkAIQYhBSQjEk0yBBJENwEaARclEjcBGgIXJBIQRDMCADEAEkQzAhAhBBJEMwIhIxJEMwIiIxwSRDMCIyEHEkQzAiQjEkQzAiWACFRNUE9PTDExEkQzAiZRAA+AD1RpbnltYW5Qb29sMS4xIBJEMwIngBNodHRwczovL3RpbnltYW4ub3JnEkQzAikyAxJEMwIqMgMSRDMCKzIDEkQzAiwyAxJEMwMAMQASRDMDECEFEkQzAxElEkQzAxQxABJEMwMSIxJEJCMTQAAQMwEBMwIBCDMDAQg1AUIBsTMEADEAEkQzBBAhBRJEMwQRJBJEMwQUMQASRDMEEiMSRDMBATMCAQgzAwEIMwQBCDUBQgF8MgQhBhJENwEcATEAE0Q3ARwBMwQUEkQzAgAxABNEMwIUMQASRDMDADMCABJEMwIRJRJEMwMUMwMHMwMQIhJNMQASRDMDESMzAxAiEk0kEkQzBAAxABJEMwQUMwIAEkQzAQEzBAEINQFCAREyBCEGEkQ3ARwBMQATRDcBHAEzAhQSRDMDFDMDBzMDECISTTcBHAESRDMCADEAEkQzAhQzBAASRDMCESUSRDMDADEAEkQzAxQzAwczAxAiEk0zBAASRDMDESMzAxAiEk0kEkQzBAAxABNEMwQUMQASRDMBATMCAQgzAwEINQFCAJAyBCEFEkQ3ARwBMQATRDMCADcBHAESRDMCADEAE0QzAwAxABJEMwIUMwIHMwIQIhJNMQASRDMDFDMDBzMDECISTTMCABJEMwEBMwMBCDUBQgA+MgQhBBJENwEcATEAE0QzAhQzAgczAhAiEk03ARwBEkQzAQEzAgEINQFCABIyBCEEEkQzAQEzAgEINQFCAAAzAAAxABNEMwAHMQASRDMACDQBD0M=",address:"ABUKAXTANWR6K6ZYV75DWJEPVWWOU6SFUVRI6QHO44E4SIDLHBTD2CZ64A",size:881,variables:[{name:"TMPL_ASSET_ID_1",type:"int",index:15,length:10},{name:"TMPL_ASSET_ID_2",type:"int",index:5,length:10},{name:"TMPL_VALIDATOR_APP_ID",type:"int",index:74,length:10}],source:"https://github.com/tinymanorg/tinyman-contracts-v1/tree/dc9ab40c58b85c15d58f63a1507e18be76720dbb/contracts/pool_logicsig.teal.tmpl"},name:"pool_logicsig"},h={type:"app",approval_program:{bytecode:"BCAHAAHoB+UHBf///////////wHAhD0mDQFvAWUBcAJhMQJhMgJsdARzd2FwBG1pbnQBdAJjMQJwMQJjMgJwMjEZgQQSMRkhBBIRMRmBAhIRQATxMRkjEjEbIhIQQATjNhoAgAZjcmVhdGUSQATUMRkjEjYaAIAJYm9vdHN0cmFwEhBAA/MzAhIzAggINTQiK2I1ZSI0ZXAARDUBIicEYjVmNGZAABEiYCJ4CTEBCDMACAk1AkIACCI0ZnAARDUCIicFYjVnKDRlFlA1byI0b2I1PSg0ZhZQNXAiNHBiNT4oNGcWUDVxIjRxYjU/IipiNUA0ATQ9CTVHNAI0Pgk1SDEAKVA0ZRZQNXkxAClQNGYWUDV6MQApUDRnFlA1ezYaAIAGcmVkZWVtEkAAWjYaAIAEZmVlcxJAABw2GgAnBhI2GgAnBxIRNhoAgARidXJuEhFAAG0ANGdJRDMCERJEMwISRDMCFDIJEkQ0PzMCEgk1PzRAMwISCTVAIio0QGYiNHE0P2YjQzMCFDMCBzMCECMSTTYcARJENDREIigzAhEWUEpiNDQJZiMxAClQMwIRFlBKYjQ0CUlBAANmI0NIaCNDMgciJwhiCUk1+kEARiInCWIiJwpiNPodTEAANx4hBSMeHzX7SEhIIicLYiInDGI0+h1MQAAdHiEFIx4fNfxISEgiJwk0+2YiJws0/GYiJwgyB2YzAxIzAwgINTU2HAExABNENGdBACIiNGdwAEQ1BiIcNAYJND8INQQ2GgAnBhJAASA0ZzMEERJENhoAJwcSQABVNhwBMwQAEkQzBBI0Rx00BCMdH0hITEhJNRA0NAk1yTMEEjRIHTQEIx0fSEhMSEk1ETQ1CTXKNBA0ERBENEc0EAk1UTRINBEJNVI0BDMEEgk1U0ICCjYcATMCABJENEc0NAg1UTRINDUINVI0BCISQAAuNDQ0BB00RyMdH0hITEg0NTQEHTRIIx0fSEhMSEoNTUk0BAg1UzMEEgk1y0IBvyInBTMEEUk1Z2YoNGcWUDVxIjRncABERDRnNGUTRDRnNGYTRDMEEiQISR018DQ0NDUdNfFKDEAACBJENPA08Q5EMwQSJAgjCEkdNfA0NDQ1HTXxSg1AAAgSRDTwNPENRCQ1PzQEMwQSJAgINVNCAU82HAEzAgASRDMCETRlEjMDETRmEhBJNWRAABkzAhE0ZhIzAxE0ZRIQRDRINRI0RzUTQgAINEc1EjRINRM2GgGAAmZpEkAAWjYaAYACZm8SRDQ1JAs0Eh00EzQ1CSUdH0hITEgjCEk1FSINNDU0EwwQRDQ0NBUJNGRBABM1yTRHNBUINVE0SDQ1CTVSQgBnNco0SDQVCDVSNEc0NQk1UUIAVDQ0STUVJQs0Ex00EiQLNDQlCx4fSEhMSEk1FCINNBQ0EwwQRDQUNDUJNGRBABM1yjRHNDQINVE0SDQUCTVSQgATNck0RzQUCTVRNEg0NAg1UkIAADQVIQQLNAQdgaCcATQSHR9ISExISTUqNAQINVNCADsiKzYaARdJNWVmIicENhoCF0k1ZmY0ZXEDRIABLVCABEFMR080ZkEABkg0ZnEDRFAzAiZJFYEPTFISQyIqNEA0KghmIjRxND80Kgg0ywhmIjRvND00yQhmIjRwND40yghmIoACczE0UWYigAJzMjRSZiInCjRSIQYdNFEjHR9ISExIZiInDDRRIQYdNFIjHR9ISExIZiKAA2lsdDRTZjTLQQAJIzR7SmI0ywhmNMlBAAkjNHlKYjTJCGY0ykEACSM0ekpiNMoIZiNDI0MiQw==",address:"BUQHXHPLMYUVS3P2INJ2EUJFCSNT6LNUGXVM6T2SZ27TDRDYLUMWCFYW3E",size:1351,variables:[],source:"https://github.com/tinymanorg/tinyman-contracts-v1/tree/dc9ab40c58b85c15d58f63a1507e18be76720dbb/contracts/validator_approval.teal"},clear_program:{bytecode:"BIEB",address:"P7GEWDXXW5IONRW6XRIRVPJCT2XXEQGOBGG65VJPBUOYZEJCBZWTPHS3VQ",size:3,variables:[],source:"https://github.com/tinymanorg/tinyman-contracts-v1/tree/dc9ab40c58b85c15d58f63a1507e18be76720dbb/contracts/validator_clear_state.teal"},global_state_schema:{num_uints:0,num_byte_slices:0},local_state_schema:{num_uints:16,num_byte_slices:0},name:"validator_app"};const w=new class{constructor(t,s){this.poolLogicSigContractTemplate=s.logic.bytecode,this.templateVariables=s.logic.variables,this.validatorApprovalContract=e.toByteArray(t.approval_program.bytecode),this.validatorClearStateContract=e.toByteArray(t.clear_program.bytecode),this.schema={numLocalInts:t.local_state_schema.num_uints,numLocalByteSlices:t.local_state_schema.num_byte_slices,numGlobalInts:t.global_state_schema.num_uints,numGlobalByteSlices:t.global_state_schema.num_byte_slices}}getPoolLogicSig({validatorAppID:s,asset1ID:a,asset2ID:n}){if(a===n)throw new Error("Assets are the same");if(n>a){const t=a;a=n,n=t}let o=Array.from(e.toByteArray(this.poolLogicSigContractTemplate));const r={asset_id_1:a,asset_id_2:n,validator_app_id:s};let i=0;this.templateVariables.sort(((t,e)=>t.index-e.index));for(let t=0;t<this.templateVariables.length;t++){const e=this.templateVariables[t];let s=r[e.name.split("TMPL_")[1].toLowerCase()],a=e.index-i,n=a+e.length,u=B(s);i+=e.length-u.length,o=o.slice(0,a).concat(u).concat(o.slice(n))}const u=new Uint8Array(o);return{addr:new t.LogicSigAccount(u).address(),program:u}}}(h,_),M=w.schema;function B(t){let e=[];for(;;){let s=127&t;if(!(t>>=7)){e.push(s);break}e.push(128|s)}return e}const R={local:{setItem(t,e){localStorage&&localStorage.setItem(t,JSON.stringify(e))},getItem(t){const e=localStorage?.getItem(t);return e?JSON.parse(e):null},removeItem(t){localStorage&&localStorage.removeItem(t)}},getFromWebStorage:t=>R.local.getItem(t),removeFromWebStorage(t){R.local.removeItem(t)},STORED_KEYS:{TINYMAN_CACHED_ASSETS:"TINYMAN_CACHED_ASSETS"}},b=R.getFromWebStorage(R.STORED_KEYS.TINYMAN_CACHED_ASSETS),P=("object"==typeof b?b:null)||{},Q={id:"0",name:"Algorand",unit_name:"ALGO",decimals:6,url:"https://algorand.org",is_liquidity_token:!1,total_amount:"6615503326932151"},O={DEFAULT:"TMPOOL11",V1:"TM1POOL"},k=Uint8Array.from([1]);var C,U;function L(t,e){return 3e5+(0===t?0:1e5)+1e5+28500*w.schema.numLocalInts+5e4*w.schema.numLocalByteSlices+e.liquidityTokenCreateTxn+e.asset1OptinTxn+e.asset2OptinTxn+e.validatorAppCallTxn}!function(t){t[t.FUNDING_TXN=0]="FUNDING_TXN",t[t.VALIDATOR_APP_CALL=1]="VALIDATOR_APP_CALL",t[t.LIQUIDITY_TOKEN_CREATE=2]="LIQUIDITY_TOKEN_CREATE",t[t.ASSET1_OPT_IN=3]="ASSET1_OPT_IN",t[t.ASSET2_OPT_IN=4]="ASSET2_OPT_IN"}(C||(C={})),exports.PoolStatus=void 0,(U=exports.PoolStatus||(exports.PoolStatus={})).NOT_CREATED="not created",U.BOOTSTRAP="bootstrap",U.READY="ready",U.ERROR="error";async function F(t,e){const s=w.getPoolLogicSig(e);let a={addr:s.addr,program:s.program,validatorAppID:e.validatorAppID,asset1ID:Math.max(e.asset1ID,e.asset2ID),asset2ID:Math.min(e.asset1ID,e.asset2ID),status:exports.PoolStatus.NOT_CREATED};const n=await Y({client:t,address:s.addr,validatorAppID:e.validatorAppID});return n&&(a.asset1ID=n.asset1ID,a.asset2ID=n.asset2ID,a.liquidityTokenID=n.liquidityTokenID,a.status=exports.PoolStatus.READY),a}const v=y("o"),X=0xffffffffffffffffn;const j=y("e");async function J({client:t,pool:s,accountAddr:n}){const o=(await t.accountInformation(n).setIntDecoding("bigint").do())["apps-local-state"]||[];let r=0n,i=0n,u=0n;for(const t of o){if(t.id!=s.validatorAppID)continue;const n=t["key-value"];if(!n)break;const o=d(n),c=e.fromByteArray(l([a.default.decodeAddress(s.addr).publicKey,j,a.default.encodeUint64(s.asset1ID)])),A=e.fromByteArray(l([a.default.decodeAddress(s.addr).publicKey,j,a.default.encodeUint64(s.asset2ID)])),I=e.fromByteArray(l([a.default.decodeAddress(s.addr).publicKey,j,a.default.encodeUint64(s.liquidityTokenID)])),g=o[c],m=o[A],p=o[I];"bigint"==typeof g&&(r=g),"bigint"==typeof m&&(i=m),"bigint"==typeof p&&(u=p)}const c={excessAsset1:r,excessAsset2:i,excessLiquidityTokens:u};if(c.excessAsset1<0n||c.excessAsset2<0n||c.excessLiquidityTokens<0n)throw new Error(`Invalid excess assets: ${c}`);return c}function q(t,e){let s=Number(e)/Number(t);return Number.isFinite(s)||(s=0),s}const z={};async function Y({client:t,address:e,validatorAppID:s}){if(z[e])return z[e];const a=await t.accountInformation(e).do(),n=a["apps-local-state"].find((t=>t.id==s));let o=null;if(n){const t=d(n["key-value"]),s="YTE=",r="YTI=",i=a["created-assets"][0].index;o={asset1ID:t[s],asset2ID:t[r],liquidityTokenID:i},z[e]=o}return o}function G(t){return Boolean(t&&!(t.asset1+t.asset2))}var W;!function(t){t[t.FEE_TXN=0]="FEE_TXN",t[t.VALIDATOR_APP_CALL_TXN=1]="VALIDATOR_APP_CALL_TXN",t[t.ASSET1_IN_TXN=2]="ASSET1_IN_TXN",t[t.ASSET2_IN_TXN=3]="ASSET2_IN_TXN",t[t.LIQUDITY_OUT_TXN=4]="LIQUDITY_OUT_TXN"}(W||(W={}));var V;!function(t){t[t.FEE_TXN=0]="FEE_TXN",t[t.VALIDATOR_APP_CALL_TXN=1]="VALIDATOR_APP_CALL_TXN",t[t.ASSET1_OUT_TXN=2]="ASSET1_OUT_TXN",t[t.ASSET2_OUT_TXN=3]="ASSET2_OUT_TXN",t[t.LIQUDITY_IN_TXN=4]="LIQUDITY_IN_TXN"}(V||(V={}));const H=3n,Z=1000n;var K,$;exports.SwapType=void 0,(K=exports.SwapType||(exports.SwapType={})).FixedInput="fixed-input",K.FixedOutput="fixed-output",function(t){t[t.FEE_TXN_INDEX=0]="FEE_TXN_INDEX",t[t.VALIDATOR_APP_CALL_TXN_INDEX=1]="VALIDATOR_APP_CALL_TXN_INDEX",t[t.ASSET_IN_TXN_INDEX=2]="ASSET_IN_TXN_INDEX",t[t.ASSET_OUT_TXN_INDEX=3]="ASSET_OUT_TXN_INDEX"}($||($={}));function tt(t,e,s){return new Promise((async(a,n)=>{try{if(0===e)return void a({asset:Q,isDeleted:!1});const n=P[`${e}`];if(n&&null!=n.asset.total_amount&&!s?.alwaysFetch)return void a(n);const o=`${t.c.baseURL.origin}/v2`,r=t.c.tokenHeader["X-Indexer-API-Token"],i=await fetch(function(t,e){return`${t}/assets/${e}?include-all=true`}(o,e),{headers:{...t.c.defaultHeaders,...r?t.c.tokenHeader:{}}}),{asset:u}=await i.json(),c={id:`${u.index}`,decimals:Number(u.params.decimals),is_liquidity_token:!1,name:u.params.name||"",unit_name:u.params["unit-name"]||"",url:"",total_amount:String(u.params.total)};P[`${e}`]={asset:c,isDeleted:u.deleted},R.local.setItem(R.STORED_KEYS.TINYMAN_CACHED_ASSETS,P),a({asset:c,isDeleted:u.deleted})}catch(t){n(new Error(t.message||"Failed to fetch asset information"))}}))}async function et({client:t,accountAddr:s,validatorAppID:n}){const o=((await t.accountInformation(s).setIntDecoding("bigint").do())["apps-local-state"]||[]).find((t=>t.id==n));let r=[];if(o&&o["key-value"]){const t=d(o["key-value"]);for(let s of Object.entries(t)){const[t,n]=s,o=e.toByteArray(t);41===o.length&&101===o[32]&&r.push({poolAddress:a.default.encodeAddress(o.slice(0,32)),assetID:a.default.decodeUint64(o.slice(33,41),"safe"),amount:parseInt(n)})}}return r}function st(t){const e=t["apps-total-schema"];return 1e5+1e5*(t.assets||[]).length+1e5*(t["created-apps"]||[]).length+1e5*(t["apps-local-state"]||[]).length+5e4*(e&&e["num-byte-slice"]||0)+28500*(e&&e["num-uint"]||0)+1e5*(t["apps-total-extra-pages"]||0)}exports.ALGO_ASSET=Q,exports.ALGO_ASSET_ID=0,exports.ASSET_OPT_IN_PROCESS_TXN_COUNT=1,exports.BASE_MINIMUM_BALANCE=1e5,exports.BURN_PROCESS_TXN_COUNT=5,exports.LIQUIDITY_TOKEN_UNIT_NAME=O,exports.MINIMUM_BALANCE_REQUIRED_PER_APP=1e5,exports.MINIMUM_BALANCE_REQUIRED_PER_ASSET=1e5,exports.MINIMUM_BALANCE_REQUIRED_PER_BYTE_SCHEMA=5e4,exports.MINIMUM_BALANCE_REQUIRED_PER_INT_SCHEMA_VALUE=28500,exports.MINIMUM_LIQUIDITY=1e3,exports.MINT_PROCESS_TXN_COUNT=5,exports.OPT_IN_VALIDATOR_APP_PROCESS_TXN_COUNT=1,exports.OPT_OUT_VALIDATOR_APP_PROCESS_TXN_COUNT=1,exports.REDEEM_PROCESS_TXN_COUNT=3,exports.SWAP_PROCESS_TXN_COUNT=4,exports.applySlippageToAmount=E,exports.burnLiquidity=async function({client:t,pool:e,txGroup:s,signedTxns:a,initiatorAddr:n}){try{const o=s[V.ASSET1_OUT_TXN].txn.amount,r=s[V.ASSET2_OUT_TXN].txn.amount,i=s[V.LIQUDITY_IN_TXN].txn.amount,u=await J({client:t,pool:e,accountAddr:n}),[{confirmedRound:c,txnID:d}]=await x(t,[a]),l=await J({client:t,pool:e,accountAddr:n});let A=l.excessAsset1-u.excessAsset1;A<0n&&(A=0n);let I=l.excessAsset2-u.excessAsset2;return I<0n&&(I=0n),{round:c,fees:N(s),asset1ID:e.asset1ID,asset1Out:BigInt(o)+A,asset2ID:e.asset2ID,asset2Out:BigInt(r)+I,liquidityID:e.liquidityTokenID,liquidityIn:BigInt(i),excessAmounts:[{assetID:e.asset1ID,excessAmountForBurning:A,totalExcessAmount:l.excessAsset1},{assetID:e.asset2ID,excessAmountForBurning:I,totalExcessAmount:l.excessAsset2}],txnID:d,groupID:S(s)}}catch(t){const e=new c(t,"We encountered something unexpected while burning liquidity. Try again later.");throw"SlippageTolerance"===e.type&&e.setMessage("The burn failed due to too much slippage in the price. Please adjust the slippage tolerance and try again."),e}},exports.calculateAccountMinimumRequiredBalance=st,exports.calculatePoolBootstrapFundingTxnAmount=L,exports.convertFromBaseUnits=D,exports.convertToBaseUnits=function(t,e){return f({decimalPlaces:0},Math.pow(10,Number(t))*Number(e))},exports.createPool=async function(t,e,s,a){return await async function({client:t,signedTxns:e,txnIDs:s}){try{await t.sendRawTransaction(e).do();const a=(await T(t,s[C.LIQUIDITY_TOKEN_CREATE]))["asset-index"];if("number"!=typeof a)throw new Error(`Generated ID is not valid: got ${a}`);return{liquidityTokenID:a}}catch(t){throw new c(t,"We encountered something unexpected while bootstraping the pool. Try again later.")}}({client:t,signedTxns:s,txnIDs:a}),F(t,e)},exports.generateBootstrapTransactions=async function({client:t,validatorAppID:e,asset1ID:s,asset2ID:n,asset1UnitName:o,asset2UnitName:r,initiatorAddr:i}){const u=await t.getTransactionParams().do(),c=w.getPoolLogicSig({asset1ID:s,asset2ID:n,validatorAppID:e}),d=a.default.makeApplicationOptInTxnFromObject({from:c.addr,appIndex:e,appArgs:[y("bootstrap"),a.default.encodeUint64(s),a.default.encodeUint64(n)],foreignAssets:0==n?[s]:[s,n],suggestedParams:u}),l=a.default.makeAssetCreateTxnWithSuggestedParamsFromObject({from:c.addr,total:0xffffffffffffffffn,decimals:6,defaultFrozen:!1,unitName:O.DEFAULT,assetName:`TinymanPool1.1 ${o}-${r}`,assetURL:"https://tinyman.org",suggestedParams:u}),A=a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:c.addr,to:c.addr,assetIndex:s,amount:0,suggestedParams:u}),I=0===n?null:a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:c.addr,to:c.addr,assetIndex:n,amount:0,suggestedParams:u});let g=[a.default.makePaymentTxnWithSuggestedParamsFromObject({from:i,to:c.addr,amount:L(n,{liquidityTokenCreateTxn:l.fee,asset1OptinTxn:A.fee,asset2OptinTxn:I?I.fee:0,validatorAppCallTxn:d.fee}),suggestedParams:u}),d,l,A];I&&g.push(I);const m=a.default.assignGroupID(g);let p=[{txn:m[0],signers:[i]},{txn:m[1],signers:[c.addr]},{txn:m[2],signers:[c.addr]},{txn:m[3],signers:[c.addr]}];return m[4]&&p.push({txn:m[4],signers:[c.addr]}),p},exports.generateBurnTxns=async function({client:t,pool:e,liquidityIn:s,asset1Out:n,asset2Out:o,slippage:r,initiatorAddr:i}){const u=await t.getTransactionParams().do(),c=a.default.makeApplicationNoOpTxnFromObject({from:e.addr,appIndex:e.validatorAppID,appArgs:[y("burn")],accounts:[i],foreignAssets:0==e.asset2ID?[e.asset1ID,e.liquidityTokenID]:[e.asset1ID,e.asset2ID,e.liquidityTokenID],suggestedParams:u}),d=E("negative",r,n),l=a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:e.addr,to:i,assetIndex:e.asset1ID,amount:d,suggestedParams:u}),A=E("negative",r,o);let I;I=0===e.asset2ID?a.default.makePaymentTxnWithSuggestedParamsFromObject({from:e.addr,to:i,amount:A,suggestedParams:u}):a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:e.addr,to:i,assetIndex:e.asset2ID,amount:A,suggestedParams:u});const g=a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:i,to:e.addr,assetIndex:e.liquidityTokenID,amount:s,suggestedParams:u});let m=c.fee+l.fee+I.fee;const p=a.default.makePaymentTxnWithSuggestedParamsFromObject({from:i,to:e.addr,amount:m,note:k,suggestedParams:u});m+=g.fee+p.fee;const T=a.default.assignGroupID([p,c,l,I,g]);return[{txn:T[V.FEE_TXN],signers:[i]},{txn:T[V.VALIDATOR_APP_CALL_TXN],signers:[e.addr]},{txn:T[V.ASSET1_OUT_TXN],signers:[e.addr]},{txn:T[V.ASSET2_OUT_TXN],signers:[e.addr]},{txn:T[V.LIQUDITY_IN_TXN],signers:[i]}]},exports.generateMintTxns=async function({client:t,pool:e,asset1In:s,asset2In:n,liquidityOut:o,slippage:r,initiatorAddr:i}){const u=E("negative",r,o),c=await t.getTransactionParams().do(),d=a.default.makeApplicationNoOpTxnFromObject({from:e.addr,appIndex:e.validatorAppID,appArgs:[y("mint")],accounts:[i],foreignAssets:0==e.asset2ID?[e.asset1ID,e.liquidityTokenID]:[e.asset1ID,e.asset2ID,e.liquidityTokenID],suggestedParams:c}),l=a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:i,to:e.addr,assetIndex:e.asset1ID,amount:s,suggestedParams:c});let A;A=0===e.asset2ID?a.default.makePaymentTxnWithSuggestedParamsFromObject({from:i,to:e.addr,amount:n,suggestedParams:c}):a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:i,to:e.addr,assetIndex:e.asset2ID,amount:n,suggestedParams:c});const I=a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:e.addr,to:i,assetIndex:e.liquidityTokenID,amount:u,suggestedParams:c}),g=a.default.makePaymentTxnWithSuggestedParamsFromObject({from:i,to:e.addr,amount:d.fee+I.fee,note:k,suggestedParams:c}),m=a.default.assignGroupID([g,d,l,A,I]);return[{txn:m[0],signers:[i]},{txn:m[1],signers:[e.addr]},{txn:m[2],signers:[i]},{txn:m[3],signers:[i]},{txn:m[4],signers:[e.addr]}]},exports.generateOptIntoAssetTxns=async function({client:t,assetID:e,initiatorAddr:s}){try{const n=await t.getTransactionParams().do();return[{txn:a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:s,to:s,assetIndex:e,amount:0,suggestedParams:n}),signers:[s]}]}catch(t){throw new c(t,"We encountered something unexpected while opting into this asset. Try again later.")}},exports.generateOptIntoValidatorTxns=async function({client:t,validatorAppID:e,initiatorAddr:s}){const n=await t.getTransactionParams().do();return[{txn:a.default.makeApplicationOptInTxnFromObject({from:s,appIndex:e,suggestedParams:n}),signers:[s]}]},exports.generateOptOutOfValidatorTxns=async function({client:t,validatorAppID:e,initiatorAddr:s}){const n=await t.getTransactionParams().do();return[{txn:a.default.makeApplicationClearStateTxnFromObject({from:s,appIndex:e,suggestedParams:n}),signers:[s]}]},exports.generateRedeemTxns=async function({client:t,pool:e,assetID:s,assetOut:n,initiatorAddr:o}){const r=await t.getTransactionParams().do(),i=a.default.makeApplicationNoOpTxnFromObject({from:e.addr,appIndex:e.validatorAppID,appArgs:[y("redeem")],accounts:[o],foreignAssets:0==e.asset2ID?[e.asset1ID,e.liquidityTokenID]:[e.asset1ID,e.asset2ID,e.liquidityTokenID],suggestedParams:r});let u;u=0===s?a.default.makePaymentTxnWithSuggestedParamsFromObject({from:e.addr,to:o,amount:BigInt(n),suggestedParams:r}):a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:e.addr,to:o,assetIndex:s,amount:BigInt(n),suggestedParams:r});const c=a.default.makePaymentTxnWithSuggestedParamsFromObject({from:o,to:e.addr,amount:i.fee+u.fee,note:k,suggestedParams:r}),d=a.default.assignGroupID([c,i,u]);return[{txn:d[0],signers:[o]},{txn:d[1],signers:[e.addr]},{txn:d[2],signers:[e.addr]}]},exports.generateSwapTransactions=async function({client:t,pool:e,swapType:s,assetIn:n,assetOut:o,slippage:r,initiatorAddr:i}){const u=await t.getTransactionParams().do(),c=[y("swap"),s===exports.SwapType.FixedInput?y("fi"):y("fo")],d=a.default.makeApplicationNoOpTxnFromObject({from:e.addr,appIndex:e.validatorAppID,appArgs:c,accounts:[i],foreignAssets:0==e.asset2ID?[e.asset1ID,e.liquidityTokenID]:[e.asset1ID,e.asset2ID,e.liquidityTokenID],suggestedParams:u}),l=s===exports.SwapType.FixedOutput?E("positive",r,n.amount):n.amount;let A;A=0===n.assetID?a.default.makePaymentTxnWithSuggestedParamsFromObject({from:i,to:e.addr,amount:l,suggestedParams:u}):a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:i,to:e.addr,assetIndex:n.assetID,amount:l,suggestedParams:u});const I=s===exports.SwapType.FixedInput?E("negative",r,o.amount):o.amount;let g;g=0===o.assetID?a.default.makePaymentTxnWithSuggestedParamsFromObject({from:e.addr,to:i,amount:I,suggestedParams:u}):a.default.makeAssetTransferTxnWithSuggestedParamsFromObject({from:e.addr,to:i,assetIndex:o.assetID,amount:I,suggestedParams:u});const m=a.default.makePaymentTxnWithSuggestedParamsFromObject({from:i,to:e.addr,amount:d.fee+g.fee,note:k,suggestedParams:u}),p=a.default.assignGroupID([m,d,A,g]);return[{txn:p[0],signers:[i]},{txn:p[1],signers:[e.addr]},{txn:p[2],signers:[i]},{txn:p[3],signers:[e.addr]}]},exports.getAccountInformation=function(t,e){return new Promise((async(s,a)=>{try{const a=await t.accountInformation(e).do();s({...a,minimum_required_balance:st(a)})}catch(t){a(new Error(t.message||"Failed to fetch account information"))}}))},exports.getAssetInformationById=tt,exports.getBootstrapProcessTxnCount=function(t){return 0===t?4:5},exports.getBurnLiquidityQuote=function({pool:t,reserves:e,liquidityIn:s}){const a=BigInt(s),n=e.issuedLiquidity&&a*e.asset1/e.issuedLiquidity,o=e.issuedLiquidity&&a*e.asset2/e.issuedLiquidity;return{round:e.round,liquidityID:t.liquidityTokenID,liquidityIn:a,asset1ID:t.asset1ID,asset1Out:n,asset2ID:t.asset2ID,asset2Out:o}},exports.getExcessAmounts=et,exports.getExcessAmountsWithPoolAssetDetails=async function({client:t,indexer:e,accountAddr:s,validatorAppID:a,assetInformationHelperOptions:n}){const o=await et({client:t,accountAddr:s,validatorAppID:a});let r=[];for(let s of o){const{poolAddress:o,assetID:i,amount:u}=s,c=await Y({client:t,address:o,validatorAppID:a});if(c){const s=await F(t,{validatorAppID:a,asset1ID:c.asset1ID,asset2ID:c.asset2ID}),o=await Promise.all([tt(e,c.asset1ID,n),tt(e,c.asset2ID,n),tt(e,s.liquidityTokenID,n)]);let d=o[0].asset;i===Number(o[1].asset.id)?d=o[1].asset:i===Number(o[2]?.asset.id)&&(d=o[2].asset),r.push({amount:u,asset:d,pool:{info:s,asset1:o[0].asset,asset2:o[1].asset,liquidityAsset:o[2].asset}})}}return r},exports.getMintLiquidityQuote=function({pool:t,reserves:e,asset1In:s,asset2In:a}){if(0n===e.issuedLiquidity){const n=BigInt(Math.floor(Math.sqrt(Number(s)*Number(a))));if(n<=BigInt(1e3))throw new Error(`Initial liquidity mint too small. Liquidity minting amount must be greater than 1000, this quote is for ${n}.`);return{round:e.round,asset1ID:t.asset1ID,asset1In:BigInt(s),asset2ID:t.asset2ID,asset2In:BigInt(a),liquidityID:t.liquidityTokenID,liquidityOut:n-BigInt(1e3),share:1}}const n=BigInt(s)*e.issuedLiquidity/e.asset1,o=BigInt(a)*e.issuedLiquidity/e.asset2,r=n<o?n:o;return{round:e.round,asset1ID:t.asset1ID,asset1In:BigInt(s),asset2ID:t.asset2ID,asset2In:BigInt(a),liquidityID:t.liquidityTokenID,liquidityOut:r,share:q(e.issuedLiquidity+r,r)}},exports.getPoolInfo=F,exports.getPoolPairRatio=function(t,e){const s=G(e);let a=null;return e&&!s&&e.asset1&&e.asset2&&"number"==typeof t.asset2&&"number"==typeof t.asset1&&(a=D(t.asset1,e.asset1)/D(t.asset2,e.asset2)),a},exports.getPoolReserves=async function(t,s){const n=await t.accountInformation(s.addr).setIntDecoding("bigint").do(),o=n["apps-local-state"]||[];let r=0n,i=0n,u=0n;for(const t of o){if(t.id!=s.validatorAppID)continue;const n=t["key-value"];if(!n)break;const o=d(n),c=e.fromByteArray(l([v,a.default.encodeUint64(s.asset1ID)])),A=e.fromByteArray(l([v,a.default.encodeUint64(s.asset2ID)])),I=e.fromByteArray(l([v,a.default.encodeUint64(s.liquidityTokenID)])),g=o[c],m=o[A],p=o[I];"bigint"==typeof g&&(r=g),"bigint"==typeof m&&(i=m),"bigint"==typeof p&&(u=p)}let c=0n,T=0n,E=0n;for(const t of n.assets){const e=t["asset-id"],{amount:a}=t;e==s.asset1ID?c=BigInt(a):e==s.asset2ID?T=BigInt(a):e==s.liquidityTokenID&&(E=BigInt(a))}if(0===s.asset2ID){const t=function(t){const e=t["apps-total-schema"];let s=0n,a=0n;e&&(e["num-byte-slice"]&&(s=e["num-byte-slice"]),e["num-uint"]&&(a=e["num-uint"]));const n=t["apps-local-state"]||[],o=t["created-apps"]||[],r=t.assets||[];return A+I*BigInt(r.length)+g*BigInt(o.length+n.length)+p*a+m*s}(n);T=BigInt(n.amount)-t}const D={round:Number(n.round),asset1:c-r,asset2:T-i,issuedLiquidity:X-E+u};if(D.asset1<0n||D.asset2<0n||D.issuedLiquidity<0n||D.issuedLiquidity>X)throw D.asset1=Number(D.asset1),D.asset2=Number(D.asset2),D.issuedLiquidity=Number(D.issuedLiquidity),new Error(`Invalid pool reserves: ${JSON.stringify(D)}`);return D},exports.getPoolShare=q,exports.getStakingAppID=function(t){return"testnet"===t?51948952:649588853},exports.getSwapQuote=function(t,e,s,a,n){let o;return o="fixed-input"===t?function({pool:t,reserves:e,assetIn:s,decimals:a}){const n=BigInt(s.amount);let o,r,i;s.assetID===t.asset1ID?(o=t.asset2ID,r=e.asset1,i=e.asset2):(o=t.asset1ID,r=e.asset2,i=e.asset1);const u=n*H/Z,c=i-r*i/(r+(n-u));if(c>i)throw new Error("Output amount exceeds available liquidity.");const d=D(a.assetOut,Number(c))/D(a.assetIn,Number(n)),l=1/d,A=D(a.assetIn,Number(r))/D(a.assetOut,Number(i)),I=f({decimalPlaces:5},Math.abs(l/A-1));return{round:e.round,assetInID:s.assetID,assetInAmount:n,assetOutID:o,assetOutAmount:c,swapFee:Number(u),rate:d,priceImpact:I}}({pool:e,reserves:s,assetIn:a,decimals:n}):function({pool:t,reserves:e,assetOut:s,decimals:a}){const n=BigInt(s.amount);let o,r,i;if(s.assetID===t.asset1ID?(o=t.asset2ID,r=e.asset2,i=e.asset1):(o=t.asset1ID,r=e.asset1,i=e.asset2),n>i)throw new Error("Output amount exceeds available liquidity.");const u=r*i/(i-n)-r,c=u*H/Z,d=u+c,l=D(a.assetOut,Number(n))/D(a.assetIn,Number(d)),A=1/l,I=D(a.assetIn,Number(r))/D(a.assetOut,Number(i)),g=f({decimalPlaces:5},Math.abs(A/I-1));return{round:e.round,assetInID:o,assetInAmount:d,assetOutID:s.assetID,assetOutAmount:n,swapFee:Number(c),rate:l,priceImpact:g}}({pool:e,reserves:s,assetOut:a,decimals:n}),o},exports.getTxnGroupID=S,exports.getValidatorAppID=function(t){const e=n[t];if(!e)throw new Error(`No Validator App exists for network ${t}`);return e},exports.hasSufficientMinimumBalance=function(t){return t.amount>=t.minimum_required_balance},exports.isNFT=function(t){return 1===parseFloat(t.total_amount)},exports.isOptedIntoValidator=function({validatorAppID:t,accountAppsLocalState:e}){return e.some((e=>e.id===t))},exports.isPoolEmpty=G,exports.isPoolNotCreated=function(t){return t?.status===exports.PoolStatus.NOT_CREATED},exports.isPoolReady=function(t){return t?.status===exports.PoolStatus.READY},exports.issueSwap=async function({client:t,pool:e,swapType:s,txGroup:a,signedTxns:n,initiatorAddr:o}){try{const r={assetID:a[$.ASSET_IN_TXN_INDEX].txn.assetIndex||0,amount:a[$.ASSET_IN_TXN_INDEX].txn.amount},i={assetID:a[$.ASSET_OUT_TXN_INDEX].txn.assetIndex||0,amount:a[$.ASSET_OUT_TXN_INDEX].txn.amount};let u;return u=s===exports.SwapType.FixedInput?await async function({client:t,pool:e,signedTxns:s,assetIn:a,assetOut:n,initiatorAddr:o}){const r=await J({client:t,pool:e,accountAddr:o});let[{confirmedRound:i,txnID:u}]=await x(t,[s]);const c=await J({client:t,pool:e,accountAddr:o});let d,l;n.assetID===e.asset1ID?(d=r.excessAsset1,l=c.excessAsset1):(d=r.excessAsset2,l=c.excessAsset2);let A=l-d;return A<0n&&(A=0n),{round:i,assetInID:a.assetID,assetInAmount:BigInt(a.amount),assetOutID:n.assetID,assetOutAmount:BigInt(n.amount)+A,excessAmount:{assetID:n.assetID,excessAmountForSwap:A,totalExcessAmount:l},txnID:u}}({client:t,pool:e,signedTxns:n,assetIn:r,assetOut:i,initiatorAddr:o}):await async function({client:t,pool:e,signedTxns:s,assetIn:a,assetOut:n,initiatorAddr:o}){const r=await J({client:t,pool:e,accountAddr:o});let[{confirmedRound:i,txnID:u}]=await x(t,[s]);const c=await J({client:t,pool:e,accountAddr:o});let d,l;a.assetID===e.asset1ID?(d=r.excessAsset1,l=c.excessAsset1):(d=r.excessAsset2,l=c.excessAsset2);let A=l-d;return A<0n&&(A=0n),{round:i,assetInID:a.assetID,assetInAmount:BigInt(a.amount)-A,assetOutID:n.assetID,assetOutAmount:BigInt(n.amount),excessAmount:{assetID:a.assetID,excessAmountForSwap:A,totalExcessAmount:l},txnID:u}}({client:t,pool:e,signedTxns:n,assetIn:r,assetOut:i,initiatorAddr:o}),{...u,groupID:S(a),fees:N(a)}}catch(t){const e=new c(t,"We encountered something unexpected while swapping. Try again later.");throw"SlippageTolerance"===e.type&&e.setMessage("The swap failed due to too much slippage in the price. Please adjust the slippage tolerance and try again."),e}},exports.mintLiquidity=async function({client:t,pool:e,txGroup:s,signedTxns:a,initiatorAddr:n}){try{const o=BigInt(s[W.LIQUDITY_OUT_TXN].txn.amount),r=await J({client:t,pool:e,accountAddr:n}),[{confirmedRound:i,txnID:u}]=await x(t,[a]),c=N(s),d=S(s),l=await J({client:t,pool:e,accountAddr:n});let A=l.excessLiquidityTokens-r.excessLiquidityTokens;return A<0n&&(A=0n),{round:i,fees:c,liquidityID:e.liquidityTokenID,liquidityOut:o+A,excessAmount:{excessAmountForMinting:A,totalExcessAmount:l.excessLiquidityTokens},txnID:u,groupID:d}}catch(t){const e=new c(t,"We encountered something unexpected while minting liquidity. Try again later.");throw"SlippageTolerance"===e.type&&e.setMessage("Minting failed due to too much slippage in the price. Please adjust the slippage tolerance and try again."),e}},exports.prepareCommitTransactions=async function({client:e,stakingAppID:s,initiatorAddr:a,liquidityAssetID:n,program:o,amount:r}){const i=await e.getTransactionParams().do(),u=t.encodeUint64(r),c=t.encodeUint64(o.id);return[{txn:t.makeApplicationNoOpTxnFromObject({appIndex:s,from:a,suggestedParams:i,foreignAssets:[n],accounts:[o.accountAddress],appArgs:[y("commit"),u],note:l([y("tinymanStaking/v1:b"),c,t.encodeUint64(n),u])}),signers:[a]}]},exports.redeemAllExcessAsset=async function({client:t,data:e,initiatorSigner:s}){try{const n=e.map((({txGroup:t,pool:e})=>({txns:t,txnFees:N(t),groupID:S(t),lsig:a.default.makeLogicSig(e.program)}))),o=await s(n.map((t=>t.txns)));return Promise.all(n.map(((e,s)=>new Promise((async(n,r)=>{try{const r=e.txns.map(((t,n)=>{if(0===n)return o[s];const{blob:r}=a.default.signLogicSigTransactionObject(t.txn,e.lsig);return r})),[{txnID:i,confirmedRound:u}]=await x(t,[r]);n({fees:e.txnFees,groupID:e.groupID,txnID:i,confirmedRound:u})}catch(t){r(t)}})))))}catch(t){throw new c(t,"We encountered something unexpected while redeeming. Try again later.")}},exports.redeemExcessAsset=async function({client:t,pool:e,txGroup:s,initiatorSigner:n}){try{const o=await async function({txGroup:t,pool:e,initiatorSigner:s}){const[n]=await s([t]),o=a.default.makeLogicSig(e.program);return t.map(((t,e)=>{if(0===e)return n;const{blob:s}=a.default.signLogicSigTransactionObject(t.txn,o);return s}))}({txGroup:s,pool:e,initiatorSigner:n}),[{txnID:r,confirmedRound:i}]=await x(t,[o]);return{fees:N(s),confirmedRound:i,txnID:r,groupID:S(s)}}catch(t){throw new c(t,"We encountered something unexpected while redeeming. Try again later.")}},exports.sendAndWaitRawTransaction=x,exports.signBootstrapTransactions=async function({txGroup:t,initiatorSigner:e,validatorAppID:s,asset1ID:n,asset2ID:o}){const[r]=await e([t]),i=w.getPoolLogicSig({asset1ID:n,asset2ID:o,validatorAppID:s}),u=a.default.makeLogicSig(i.program),c=[];return{signedTxns:t.map(((t,e)=>{if(e===C.FUNDING_TXN)return c.push(t.txn.txID().toString()),r;const{txID:s,blob:n}=a.default.signLogicSigTransactionObject(t.txn,u);return c.push(s),n})),txnIDs:c}},exports.signBurnTxns=async function({pool:t,txGroup:e,initiatorSigner:s}){const[n,o]=await s([e]),r=a.default.makeLogicSig(t.program);return e.map(((t,e)=>{if(e===V.FEE_TXN)return n;if(e===V.LIQUDITY_IN_TXN)return o;const{blob:s}=a.default.signLogicSigTransactionObject(t.txn,r);return s}))},exports.signMintTxns=async function({pool:t,txGroup:e,initiatorSigner:s}){const n=a.default.makeLogicSig(t.program),[o,r,i]=await s([e]);return e.map(((t,e)=>{if(e===W.FEE_TXN)return o;if(e===W.ASSET1_IN_TXN)return r;if(e===W.ASSET2_IN_TXN)return i;const{blob:s}=a.default.signLogicSigTransactionObject(t.txn,n);return s}))},exports.signSwapTransactions=async function({pool:t,txGroup:e,initiatorSigner:s}){const n=a.default.makeLogicSig(t.program),[o,r]=await s([e]);return e.map(((t,e)=>{if(e===$.FEE_TXN_INDEX)return o;if(e===$.ASSET_IN_TXN_INDEX)return r;const{blob:s}=a.default.signLogicSigTransactionObject(t.txn,n);return s}))},exports.sumUpTxnFees=N,exports.validatorAppSchema=M;
